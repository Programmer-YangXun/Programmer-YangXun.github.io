<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[An Easy Way to Hook Functions on Windows OS]]></title>
    <url>%2F2019%2F01%2F24%2F2019-01-24-An-Easy-Way-To-Hook-Functions-On-Windows-OS%2F</url>
    <content type="text"><![CDATA[Brief Introduction to Hook A hook is a point in the system message-handling mechanism where an application can install a subroutine to monitor the message traffic in the system and process certain types of messages before they reach the target window procedure. On Windows OS, there are a set of functions designed to hook/unhook windows in Windows API. For example, SetWindowsHookExW Installs an application-defined hook procedure into a hook chain. You would install a hook procedure to monitor the system for certain types of events. These events are associated either with a specific thread or with all threads in the same desktop as the calling thread. SetWindowsHookEx can be used to inject a DLL into another process. UnhookWindowsHookEx Removes a hook procedure installed in a hook chain by the SetWindowsHookEx function. By using Hook, we will be able to get/set data in hooked processes, and even modify codes dynamically. To understand the following part of this article, you must Have learned C/C++ Programming Language and Assembly Language (Intel x86) Have written Win32 Applications codes by using Windows API Have written DLL (Dynamic Link Library) codes How to Hook WindowsFirst, we can create an empty DLL project “HookLib”, and put the following codes in header file “HookLib.h”12345678#pragma once#include &lt;Windows.h&gt;#ifndef HOOKLIB_API#define HOOKLIB_API extern __declspec(dllimport)#endifHOOKLIB_API VOID SetGlobalWindowsHook(VOID); Then put the following codes in source file “HookLib.c”123456789101112131415161718192021222324252627#define HOOKLIB_API __declspec(dllexport)#include "HookLib.h"#pragma comment(lib, "Advapi32.lib")#pragma comment(lib, "User32.lib")HHOOK hHook;HMODULE hModule;LRESULT WINAPI GetMsgProc(int code, WPARAM wParam, LPARAM lParam)&#123; return CallNextHookEx(hHook, code, wParam, lParam);&#125;HOOKLIB_API VOID SetGlobalWindowsHook(VOID)&#123; hHook = SetWindowsHookExW(WH_GETMESSAGE, GetMsgProc, (HINSTANCE)hModule, 0);&#125;BOOL APIENTRY DllMain(HMODULE hInstance, DWORD fdwReason, LPVOID lpvReserved)&#123; switch (fdwReason) &#123; case DLL_PROCESS_ATTACH: hModule = hInstance; break; case DLL_PROCESS_DETACH: UnhookWindowsHookEx(hHook); break; &#125; return TRUE;&#125; At last, we add this DLL reference to our own Win32 Application project, and call the function SetGlobalWindowsHook, then a global windows hook should be set. You can change the arguments passed to SetWindowsHookExW, and hook specified windows instead. Please note A 32-bit DLL cannot be injected into a 64-bit process, and a 64-bit DLL cannot be injected into a 32-bit process. If an application requires the use of hooks in other processes, it is required that a 32-bit application call SetWindowsHookEx to inject a 32-bit DLL into 32-bit processes, and a 64-bit application call SetWindowsHookEx to inject a 64-bit DLL into 64-bit processes. The 32-bit and 64-bit DLLs must have different names. If we want to set a hook successfully, we must set target platform correctly. In addition, access right is required for some processes (e.g. Windows Task Manager), and we can solve this by running our programs as Administrator in most cases. How to Hook FunctionsThe following is a basic and short tutorial that teaches you how to use Hook and other techniques to protect your running applications from being terminated by Windows Task Manager, and you will learn the techniques of hooking functions. As every Windows Programmer knows, most Win32 Applications call Windows API OpenProcess to get the handle of a process, and the process can be terminated by calling TerminateProcess, if the handle passed the function has no process access right PROCESS_TERMINATE, the function will fail. Windows Task Manager is no exception. This information is enough for us to get started. The Assembly Language (Intel x86) codes of a function usually consist of the following snippets12345678foobar procpush ebpmov ebp, esp; ...mov esp, ebppop ebpretfoobar endp The size of these codes are greater than 5 bytes, so once our DLL is injected to a process and overwrite first 5-byte machine codes of a function by placing our own codes &mdash; 1-byte machine code of CPU jump instruction and 4-byte displacement, we will be able to control the process. All key techniques have been explained. Here are the final-version codes in source file “HookLib.c”123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#define HOOKLIB_API __declspec(dllexport)#pragma warning(disable:4311)#include "HookLib.h"#include &lt;Shlwapi.h&gt;#include &lt;TlHelp32.h&gt;#pragma comment(lib, "Advapi32.lib")#pragma comment(lib, "Shlwapi.lib")#pragma comment(lib, "User32.lib")#pragma data_seg("SharedData")DWORD dwSpecifiedProcessId = 0; //ID of a process to be protected#pragma data_seg()#pragma comment(linker, "/SECTION:SharedData,RWS")BYTE byteOriginalOpenProcessCode[5], byteModifiedOpenProcessCode[5]; //First 5-byte machine code of specified functionsCRITICAL_SECTION CriticalSection;HANDLE hProcess; //Handle of the injected processHHOOK hHook;HMODULE hModule;DWORD WINAPI Thread_ChangeProcedureAddress(PVOID pvParam);HANDLE WINAPI ModifiedOpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);LRESULT WINAPI GetMsgProc(INT iCode, WPARAM wParam, LPARAM lParam);VOID ChangeProcedureAddress(PVOID pvProcedureAddress, PBYTE pbyteCode);BOOL APIENTRY DllMain(HMODULE hInstance, DWORD fdwReason, LPVOID lpvReserved)&#123; switch (fdwReason) &#123; case DLL_PROCESS_ATTACH: &#123; hModule = hInstance; HANDLE hToolhelp32Snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hToolhelp32Snapshot != INVALID_HANDLE_VALUE) &#123; PROCESSENTRY32W ProcessEntry32 = &#123; sizeof(ProcessEntry32) &#125;; BOOL bRet = Process32FirstW(hToolhelp32Snapshot, &amp;ProcessEntry32); while (bRet) &#123; if (!StrCmpLogicalW(L"taskmgr.exe", ProcessEntry32.szExeFile) &amp;&amp; GetCurrentProcessId() == ProcessEntry32.th32ProcessID) &#123; InitializeCriticalSection(&amp;CriticalSection); CreateThread(NULL, 0, Thread_ChangeProcedureAddress, NULL, 0, NULL); break; &#125; bRet = Process32NextW(hToolhelp32Snapshot, &amp;ProcessEntry32); &#125; CloseHandle(hToolhelp32Snapshot); &#125; &#125; break; case DLL_PROCESS_DETACH: &#123; ChangeProcedureAddress(OpenProcess, byteOriginalOpenProcessCode); DeleteCriticalSection(&amp;CriticalSection); UnhookWindowsHookEx(hHook); &#125; break; &#125; return TRUE;&#125;DWORD WINAPI Thread_ChangeProcedureAddress(PVOID pvParam)&#123; ReadProcessMemory(hProcess = GetCurrentProcess(), OpenProcess, byteOriginalOpenProcessCode, 5, NULL); //Back up first 5-byte machine code of OpenProcess *byteModifiedOpenProcessCode = 0xE9; //Machine code of jmp (x86/x86-64 CPU instruction) *(PDWORD)(byteModifiedOpenProcessCode + 1) = (DWORD)ModifiedOpenProcess - (DWORD)OpenProcess - 5; //4-byte displacement Sleep(1000); //Wait for Windows Task Manager completely initialized, 1 second should be enough ChangeProcedureAddress(OpenProcess, byteModifiedOpenProcessCode); //Overwrite first 5-byte machine codes of OpenProcess by placing modified codes return 0;&#125;HANDLE WINAPI ModifiedOpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)&#123; EnterCriticalSection(&amp;CriticalSection); if (dwProcessId == dwSpecifiedProcessId) &#123; //Force OpenProcess returns a handle that has no process access right PROCESS_TERMINATE so that TerminateProcess will fail, and the process will be protected dwDesiredAccess = 0; &#125; ChangeProcedureAddress(OpenProcess, byteOriginalOpenProcessCode); //Restore machine codes of OpenProcess so that OpenProcess can be called normally HANDLE hProcess = OpenProcess(dwDesiredAccess, bInheritHandle, dwProcessId); ChangeProcedureAddress(OpenProcess, byteModifiedOpenProcessCode); //Overwrite machine codes of OpenProcess again LeaveCriticalSection(&amp;CriticalSection); return hProcess;&#125;LRESULT WINAPI GetMsgProc(INT iCode, WPARAM wParam, LPARAM lParam)&#123; return CallNextHookEx(hHook, iCode, wParam, lParam);&#125;HOOKLIB_API VOID SetGlobalWindowsHook(VOID)&#123; dwSpecifiedProcessId = GetCurrentProcessId(); hHook = SetWindowsHookExW(WH_GETMESSAGE, GetMsgProc, (HINSTANCE)hModule, 0);&#125;VOID ChangeProcedureAddress(PVOID pvProcedureAddress, PBYTE pbyteCode)&#123; DWORD dwOldProtect; VirtualProtectEx(hProcess, pvProcedureAddress, 5, PAGE_READWRITE, &amp;dwOldProtect); WriteProcessMemory(hProcess, pvProcedureAddress, pbyteCode, 5, NULL); VirtualProtectEx(hProcess, pvProcedureAddress, 5, dwOldProtect, &amp;dwOldProtect);&#125; The complete project is hosted on https://github.com/Hydr10n/Hook. I wish this tutorial will be helpful to you.]]></content>
      <categories>
        <category>Tutorials</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MicroUtilityLib (C Language)]]></title>
    <url>%2F2019%2F01%2F14%2F2019-01-14-MicroUtilityLib(C-Language)%2F</url>
    <content type="text"><![CDATA[What’s inside the libraryIn Source File “MicroUtilityLib.c”Functions1234567891011121314151617181920212223BOOL DownloadFileFromInternetW(LPCWSTR lpcwUrl, LPCWSTR lpcwNewFileName, BOOL bFailIfFileExists);//Find all files/folders which can be accessible on a disk.//The description of the parameter LPFIND_DISK_DATA_ROUTINEW lpFindDiskData_Routine can be found in Header File "MicroUtilityLib.h"BOOL FindDiskDataW(WCHAR wchDriveLetter, LPVOID lpData, LPFIND_DISK_DATA_ROUTINEW lpFindDiskData_Routine);BOOL GetFileProductVersionW(LPCWSTR lpcwFileName, LPWSTR lpwFileProductVersionBuffer, DWORD cchFileProductVersionBuffer);//This function uses Windows API StrCmpLogicalW which works better than string compare functions like strcmp to sort strings. Strings are sorted in ascending.BOOL SortStringsLogicalW(LPWSTR *lpwStrings, DWORD dwNumberOfStrings);//This function attempts to find a specified string in strings and return the index. If the string is not found, this funtcion will return (DWORD)-1. Strings must be sorted in ascending because this function uses binary search algorithm. This function is not case-sensitive.DWORD FindStringInSortedStringsLogicalW(LPCWSTR lpcwStringToFind, LPWSTR *lpwStrings, DWORD dwLowerBound, DWORD dwUpperBound);DWORD GetFileCRC32W(LPCWSTR lpcwFileName);INT GetCurrentDPI(AXIS Axis);//This function attempts to get the base address of a process, but might fail if no access rights.PVOID GetProcessBaseAddress(DWORD dwProcessID);//This function attempts to delete the executable file of current process, but might fail in some cases.VOID DeleteSelf(VOID); In Header File “MicroUtilityLib.h”Macros12345678910111213141516171819202122//This macro converts the case of a character into lowerToLowerCaseW(ch);ToLowerCaseA(ch);//This macro converts the case of a character into upperToLowerUpperW(ch);ToLowerUpperA(ch);//This macro combines two WORD integers into one DWORD integerMAKEDWORD(HIGH_WORD, LOW_WORD);//This macro combines two DWORD integers into one DWORD64 integerMAKEDWORD64(HIGH_DWORD, LOW_DWORD);//This macro scales standard width (in pixels) to fit current DPIScaleX(iX, iCurrentDpi_X);//This macro scales standard height (in pixels) to fit current DPIScaleY(iY, iCurrentDpi_Y);//This macro creates a window which fits current DPIDPIAware_CreateWindowExW(iCurrentDpi_X, iCurrentDpi_Y, dwExStyle, lpClassName, lpWindowName, dwStyle, iX, iY, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam); Data Types12345678typedef enum _AXIS &#123; AxisX = LOGPIXELSX, AxisY = LOGPIXELSY &#125; AXIS;//This is a callback function used for FindDiskDataW.//Parameters in this function contain most information of current file/folder.//return FALSE to stop function FindDiskDataWtypedef BOOL(CALLBACK* LPFIND_DISK_DATA_ROUTINEW)(LPWIN32_FIND_DATAW lpWin32_FindData, LPWSTR lpwPathName, LPVOID lpData);LPFIND_DISK_DATA_ROUTINEW lpFindDiskData_Routine;DWORD lpFindDiskData_Routine(LPWIN32_FIND_DATAW lpWin32_FindData, LPWSTR lpwPathName, LPVOID lpData); Please note Functions/Macros/Data Types ending with ‘W’ process Unicode strings, ‘A’ process ANSI strings. Supported PlatformOS: Microsoft&reg; Windows&reg; 7 and above]]></content>
      <categories>
        <category>Projects</category>
        <category>Libraries</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F14%2F2019-01-14-Hello-World%2F</url>
    <content type="text"><![CDATA[Welcome to my blog!Finally I decided to create my own blog after working on computer for so many years, and I will post/update my technical articles regularly. Please share my blog if you like it. I’d be really appreciated if you could provide some suggestions or point out my mistakes :) &mdash; Xun Yang (aka Hydr10n on GitHub)]]></content>
      <categories>
        <category>Logs</category>
      </categories>
  </entry>
</search>
